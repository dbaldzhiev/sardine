Limitations and Constraints
The Sardine parking layout solver is a powerful tool but operates within specific architectural and geometric constraints. This section outlines what the plugin does not handle, known edge cases, and where users must apply discretion. All dimensions below are in centimeters (cm) for consistency with European conventions.
Architectural & Regulatory Constraints
Single Plot Only: The solver works on one continuous, flat site boundary at a time. It supports only a single closed polyline as the parking lot outline, with no internal obstacles or multi-level structures. It cannot account for buildings or other exclusion zones inside the lot – such cases must be handled manually or by splitting the lot (the plugin is not intended for garages or multi-story parking).
Flat Terrain: The layout logic assumes a flat horizontal plane. Ramp inclines, multi-tier parking, or significant grade changes are not considered. The tool does not model vertical clearance or sloped surfaces, so height constraints (e.g. low ceilings, overhangs) must be verified by the user if applying the design in a garage or under a structure.
Regulatory Dimensions: By default, the plugin uses standard European parking bay dimensions (around 250 cm width by 500 cm length for a 90° stall). These align with typical EU norms where standard spaces range ~230–250 cm wide. Bulgarian regulations, however, have recently mandated larger minimums for new developments – at least 275 cm width and 550 cm length per car space. Users should adjust the spot size parameters if needed to meet local code. The solver allows customizing stall width/length, so for Bulgarian compliance one should set width ≥275 and length ≥550. Keep in mind that using smaller widths (e.g. 220–230 cm, which were historically permitted for tightly angled or parallel parking) can maximize count but may violate current standards or impede door opening. Always confirm the chosen stall size against local building codes.
Aisle Width and Circulation: The plugin defaults to a two-way drive aisle width that should accommodate standard cars. Typically, a two-way circulation aisle of ~600 cm is recommended for perpendicular parking (this meets common European practice for comfortable maneuvering). One-way aisles (for angled layouts) can be narrower (on the order of 350–400 cm, depending on angle), but the plugin may not automatically enforce one-way logic unless an angled parking template is used. Bulgarian and EU guidelines generally require at least ~600 cm for aisles serving 90° spaces, so users should ensure the “Access Width” in the road settings is set accordingly for two-way traffic. Insufficient aisle width could make parking unusable – the solver will still generate geometry, so it’s up to the user to respect minimum widths for safety.
Pedestrian Paths: While the solver can generate pedestrian walkways (sidewalks or lanes), it does not inherently enforce all accessibility regulations. European best practices call for clear pedestrian circulation routes within parking lots, typically at least 120 cm wide (for wheelchair accessibility). The plugin provides a “Circulation Width” setting for pedestrian lanes, but the placement of these paths (e.g. alongside aisles or around the lot perimeter) is simplified. It may not automatically connect every parking bay to a pedestrian route. Bulgarian norms require that disabled parking spaces have an accessible route to building entrances or sidewalks. In using the plugin, ensure that any generated pedestrian paths form a continuous accessible network – you might need to manually adjust or add crosswalks, especially if the automatic walkway on “Style: sidewalks” isn’t sufficient for your site layout.
Accessibility & Special Vehicles: The solver allows designation of handicapped (accessible) and elderly parking spots, but user oversight is needed to meet legal requirements. Many European regulations (including Bulgaria’s) require a certain number of accessible spaces (commonly about 4% of total capacity, with at least 2 spots minimum) and that they be located near entrances or pedestrian access points. The plugin can allocate a percentage of spots as “Handicap” and “Elderly,” but it does not automatically position them closest to the building entrance unless the user’s input parameters are set that way. The user should review where the solver placed these special spots – typically the plugin may place them at the first few spots of an aisle or near the AccessPoint if “Snap Access” is used – and ensure this placement makes sense (e.g. near the pedestrian entry path). Adjustments might be required to move accessible spots to optimal locations (near ramps, elevators, etc.) or to add required signage/markings (the solver does not add wheelchair logos or signage).
No Automatic EV Charging Allocation: Modern EU guidelines increasingly require Electric Vehicle (EV) charging spaces (for example, Bulgaria mandates that 20% of spaces in new public lots have EV chargers, with at least one high-power charger). The current plugin version does not explicitly handle EV spots – there is no built-in “electric vehicle” spot type. If EV spots are needed, the user can utilize the tagging or metadata (see below) to mark certain regular spots for EV charging and manually ensure their distribution (e.g. every 5th spot or the required percentage). This is a manual process; the solver will not enforce EV charger ratios or differentiate those spots geometrically.
No Heavy Vehicle Support: The solver is tailored for standard passenger car parking. It does not have presets for buses, trucks, or other oversized vehicle bays (which often demand larger dimensions and turning radii). If you intend to design bus or truck parking, note that the typical car stall and aisle dimensions will be insufficient – this scenario is outside the plugin’s scope. Similarly, motorcycle or scooter parking isn’t explicitly handled (though one could treat them as small car spots or convert some spaces for motorcycle use via custom tagging).
Fire Lanes and Emergency Access: In many jurisdictions, large parking lots must include fire truck access lanes or be arranged such that emergency vehicles can reach all points. The solver focuses on maximizing parking layout and basic circulation; it does not verify fire code requirements (e.g. maintaining clear routes or distances from building entrances for firefighting). Users must ensure that any additional clearance or dedicated fire lanes are accounted for, as needed, by excluding those areas or later removing spots to create the required fire access.
Geometric Limitations
Boundary Geometry: The input boundary should be a reasonably simple closed polyline. Highly concave or irregular shapes are problematic – the algorithm may fail or produce overlapping/invalid parking layouts for complex concave polygons. While many plot shapes work, a deeply notched “C” or “U” shaped polygon, for example, might confuse the solver’s inner distribution logic. If you have a concave lot, consider splitting it into simpler sub-regions or using the solver’s axial road feature to partition it, then combine results. Minor concave indentations might work but could leave odd gaps or islands. In summary, convex or gently curving polygons are handled best, whereas shapes with reentrant corners can break the solution.
Polyline Segments vs Curves: The solver expects straight-line segments in the boundary. If your boundary has arcs or splines, convert them to a polyline approximation before input. Curved edges are not explicitly supported and could lead to unpredictable spot placement along those edges. The algorithm will not perfectly align angled parking on a curved edge (since it doesn’t dynamically adjust orientation continuously along a curve). For best results, use polygonal boundaries. If curved edges remain, be prepared for some manual cleanup of spots that might not align cleanly along the curvature.
Minimum Size Requirements: Obviously, the plot must be large enough to fit at least one parking module (a parking stall plus maneuvering space). The solver doesn’t explicitly check for a minimum area, but if the boundary is extremely small (e.g. a tiny lot under ~600 cm in one dimension), no parking layout can be generated. In such cases, you may simply get no spots or an error. Ensure the site is at least roughly 1000–1500 cm in its smallest dimension to fit a couple of stalls and an aisle. Extremely narrow or oddly shaped slivers of land will not yield usable results.
Orientation Limitations: All parking spots are currently laid out at a uniform angle as defined in the spot settings (e.g. all 90° or all 45°), and aligned relative to either the plot edges or a chosen reference. The solver does not mix different orientations in one solution (e.g. you cannot have some areas with perpendicular parking and others angled in the same run – that would require running the solver separately or manually adjusting results). If the site would benefit from multiple orientations (for instance, angled parking on a triangular corner versus perpendicular elsewhere), the plugin cannot decide that automatically; the user would need to constrain the boundary or use separate runs with different angle settings. The orientation is typically aligned with one selected edge or an automatically chosen dominant axis. This means if your site is skewed or not orthogonal, the spots might align in a way that leaves triangular unused areas. The user might need to experiment with the “Reference Edge” setting or manually rotate the input boundary (or internal coordinate system) to achieve a preferred orientation.
Edge Placement and Overhangs: The solver will attempt to place parking spots along the boundary if “outer spots” are enabled. However, it does not know about physical barriers beyond the lot boundary. For example, if one edge of the lot is along a wall or property line, real designs might disallow parking that faces that edge (because car overhang or opening doors could be problematic). The plugin will still fill that edge with spots unless you exclude it (e.g. using the “Edges Cull” or limiting which edges are used). Users should manually omit edges where parking is undesirable – e.g. too close to neighboring property, or along a landscape buffer – because the solver lacks that semantic context. Also, corner spots might overhang outside the boundary slightly if the boundary corners are acute; the algorithm does trimming, but any minor overhang (a few cm of a car polygon outside the outline) might occur in rare cases and would need slight adjustment.
Islands and Leftover Spaces: The algorithm often creates “islands” – small leftover areas that are not large enough for parking or are used for circulation improvements. These islands might represent landscape buffers, pedestrian refuges, or simply unused space. The solver will generate them mainly at the ends of parking rows or where an axial road bisects the lot. Be aware that these islands are purely geometric results of the layout; the plugin doesn’t assign them any specific function unless you use the bike parking feature (see below). Thus, some islands might be very small slivers or oddly shaped polygons. Very small islands (below a certain area threshold) may effectively be artifacts – the user can choose to ignore them or merge them with adjacent pavement. In practice, designers might enlarge certain islands for tree planters or remove others to create a larger continuous parking area – such decisions are outside the solver’s automated scope.
Turning Radii and Maneuvering: The solver arranges stalls and aisles but does not simulate vehicle turning paths. It assumes that if dimensions meet standards (stall size and aisle width), cars can maneuver. However, in tricky corner cases – for example, an aisle that dead-ends against a boundary – a real driver might struggle to turn around. The plugin does not guarantee that a car can easily back out of every stall in every layout, especially if multiple turns are needed. It’s up to the user to recognize if an aisle in the solution is effectively a dead-end with no turnaround space. Best practice is to avoid dead-end aisles longer than about 5 stalls deep unless a turnaround bay is provided. The solver’s “inner roads with single access” mode (Perimetral setting 3) attempts to create dead-end aisles for internal rows (to maximize spots), but use this with caution – it may maximize count at the expense of convenient circulation. In a professional design, you might convert the end stall into a mini-turnaround or an island for easier maneuvering; the solver will not do this automatically.
Plot Unit and Scaling: Ensure your Rhino document units are set to meters (the solver’s default assumption) or that you input values in the expected unit. All internal calculations assume 1.0 = 1 meter. If you work in centimeters in Rhino, be careful – a stall width of “250” in the plugin inputs would be interpreted as 250 meters (which is obviously wrong). Thus, either use meters as the Rhino unit (e.g. enter 2.5 for a 250 cm width) or convert your values appropriately. The developer explicitly notes that the Rhino document “shall be in meters” for the plugin to work as intended. Failing to adhere can result in a wildly incorrect scale of the layout.
Known Bugs & Edge Cases
Concave Shape Failures: As noted, concave boundaries may lead to solver failure or odd layouts. Some identified bugs include boolean union failures when merging parking zones in concave corners, and misalignment of pedestrian lanes in concave configurations. If the solver crashes or produces no output on a particular shape, try simplifying the boundary or splitting the area.
Pedestrian Path Issues: The “Pedestrian Settings” are known to occasionally break the solution on certain shapes. For example, enabling sidewalks on a concave lot can cause boolean operations to fail (the walkway generation might conflict with islands). If you experience the solver failing when ped lanes are on, you might need to turn off pedestrian generation and design those manually. This is a known bug that may be addressed in future updates.
Toggling Settings Can Break Solution: Rapidly changing the configuration (such as switching between different perimetral modes, angles, or other parameters) on a given complex plot may leave the solver in an invalid state. Sometimes a certain combination of settings doesn’t play well with a particular geometry. The plugin might output an incomplete layout or none at all. Workaround: adjust one parameter at a time and allow the solver to recompute, or try a different approach (e.g. if “boundary spots on both sides” causes an issue, fall back to a simpler mode). Saving and reopening Grasshopper (with a recompute) can also reset the state if it gets stuck.
Serialization of Special Spots: A current limitation is that Handicap and Elderly designations are not saved with the Grasshopper file. If you save your work and reopen it, any spots previously marked as “Handicap” or “Elderly” will have reverted to normal spots (the percentages/toggles reset). This is a bug in the plugin’s state persistence. The implication is that after reopening a file, you must reapply the special spot settings (toggle the Handicap/Elderly checkbox components on again) to regenerate those reserved spots. Failing to do so could lead to under-provisioning of accessible spaces in your design without you realizing it. Always double-check special spots after reloading a definition.
One Solver at a Time: Only use a single instance of the main solver component in a Grasshopper document. Multiple solver components running simultaneously can interfere or cause computation errors. If you need to layout multiple separate parking areas, handle them sequentially or in separate GH files. This is a design assumption of the plugin – it wasn’t built for parallel multi-lot operation in one canvas.
“Recompute” Required on Load: An observation from the developer: after opening a saved Grasshopper file that contains a Parking Solver solution, you may need to manually trigger a recompute (Grasshopper canvas > Solution > Recompute) to see the results. Sometimes the parking geometry doesn’t display until the solver recomputes. Keep this in mind – if you open a file and see no parking, just refresh the solution.
Graphical Glitches: In some cases, minor graphical glitches have been observed – for example, preview lines or ghost geometry remaining after changes. These are typically Grasshopper preview artifacts. Baking the solution to Rhino geometry and then clearing the Grasshopper preview can resolve any display oddities. They do not affect the actual data, only the visualization.
Future Updates Disclaimer: The plugin is a work-in-progress (a “pet project” by the author) and may contain other undiscovered bugs. Users are encouraged to report issues to the developer. Stability will improve over time, but for mission-critical use, treat the results with scrutiny. Always cross-verify critical dimensions and counts.
User Discretion & Best Practices
While Sardine’s solver greatly accelerates layout generation, it is not a replacement for human judgment. Users should interpret the output as a draft proposal that may require tuning:
Review and Edit: Always review the layout for practical issues – e.g. remove a stall if it’s too close to an entrance gate, add a missing walkway in front of accessible spaces, or adjust an island shape to better guide drivers. The solver optimizes geometry but doesn’t “know” site context or safety nuances.
Compliance Check: Use local regulations as a checklist. After generating a lot, verify stall count, stall dimensions, aisle widths, accessible spot count/location, etc., against your jurisdiction’s requirements. For instance, ensure the accessible spots percentage meets the minimum (and round up to next whole number of spaces). If the solver’s percentage setting resulted in too few accessible spots, increase it or manually add one – e.g. if 4% of 45 spots gave 1.8 (rounded down to 1 spot), code would require at least 2, so set the percentage a bit higher or explicitly override to get 2 spots.
Edge Adjustment: If some edges of the plot shouldn’t have parking (such as an edge adjacent to a street where you need a setback or an edge reserved for future expansion), use the Edges Cull or Side-Out settings in the solver to exclude them, or simply delete those spots afterward. The solver won’t know about easements or sight triangles at driveways – you must remove any spots that encroach on those areas.
Safety and Flow: Consider turning paths and pedestrian flow. The solver does basic geometry; you as the designer should ensure there are no blind corners, that pedestrians can walk safely to their destination, and that vehicles can queue at the entrance without blocking public roads. For example, the first few meters inside the AccessPoint might need to be clear of parking for incoming cars – if the solver placed a spot immediately at the gate, you might want to remove it to create an entry throat.
Combine with Manual Design: Feel free to use the solver’s output as a starting point and then manually modify it. The geometry can be baked into Rhino and edited. Common tweaks might include: enlarging an island to add landscaping, shifting a row of parking a bit to align with an existing curb, or converting a few regular spots to motorcycle parking or loading zones. The solver provides a flexible layout, but final polish is in the user’s hands.
In summary, Sardine (Parking Solver) provides a geometrically robust baseline solution for open parking lots, but it has defined limits. It adheres to general European parking standards out-of-the-box, with customization needed for Bulgarian specifics and other local rules. By understanding these limitations and applying professional judgment, users can achieve a code-compliant, efficient parking design with the plugin’s help. Always treat the output as a draft to be reviewed rather than an absolute final design.