olver Stages and Logic
This section outlines the step-by-step logic that the Sardine Grasshopper plugin uses to generate an open parking lot layout. The solver employs a geometry-first strategy: it uses the spatial configuration of the plot to place parking stalls and drive aisles in a systematic way, rather than brute-force search. We will go through each stage of computation, from initial preprocessing to final output, highlighting how outer and inner parking areas are handled, how pedestrian and special spots are integrated, and ensuring all dimensions are in centimeters. The process is designed to be robust and flexible, adhering to Bulgarian and general European parking norms (stall sizes, aisle widths, circulation) by default, while allowing the user to override parameters as needed.
Assumptions: The input is a single closed polyline boundary representing a flat parking lot surface (no internal obstacles or multi-level structures). The goal is to fill this area with an efficient layout of parking stalls (and associated roads) following standard design rules.
Let's break down the solver's workflow:
Stage 1: Preprocessing and Input Validation
1.1 Boundary Check: The solver begins by verifying the provided plot boundary. It ensures the input curve is a closed polyline (or converts it to one). If the boundary is not planar, it will be projected to the base plane. Any minor gaps in closure are fixed if possible. If the boundary is self-intersecting or otherwise invalid, the solver will halt (such cases must be corrected by the user). The boundary may also be simplified – e.g., very short segments or small fillets might be ignored to avoid creating sliver parking spaces or tiny geometry. This stage sets the foundational region that all subsequent steps operate within.
1.2 Unit Standardization: The solver confirms the Rhino document units (expects meters). Internally, it works in meters but here we describe in cm. If needed, it applies a conversion so that all distances (like stall width, etc.) are interpreted correctly. This ensures that a user’s input values for dimensions correspond to real-world sizes in cm.
1.3 Parameter Intake: Next, the solver reads user-defined parameters:
The chosen parking stall dimensions (length and width, and angle of parking) for both Outer and Inner spots.
The road widths for access and axial roads.
The percentage settings for special spots (handicap, elderly).
Whether pedestrian lanes are enabled, and their width/style.
The configuration mode for using the boundary (perimeter mode 0/1/2/3).
Locations of any user-specified Axial Road lines (if provided as inputs).
Locations of Access Points (entry/exit) on the boundary.
These inputs guide the solver’s decisions in later stages. The solver may do a sanity check (e.g., ensure percentages for special spots sum to less than 100%, ensure road widths are not zero, etc.). If any parameter is out of expected range (say a stall width below plausible minimum), it might reset to default or warn the user.
1.4 Orientation Setup: The solver determines an initial orientation for the parking grid. By default, it might align to one of the plot’s edges or the longest edge. If the user selected a specific Reference Edge, that edge’s direction is used as the baseline for drawing parking rows. If not, the algorithm could choose the longest straight edge or the overall principal axis of the polygon (e.g., using an oriented bounding box). The chosen orientation will define how stalls and aisles are laid out – typically, stall rows will run parallel to this reference and aisles perpendicular (for 90° parking). For angled parking, stalls will be rotated off this axis by the given angle. This stage is crucial for irregular polygons: a well-chosen orientation maximizes how many full-length rows can fit.
1.5 Boundary Offset (“Skirt”): To avoid parking stalls hanging over the lot edge and to allow some clearance, the solver offsets the boundary inward by a small distance (the Skirt parameter, default ~50 cm). This creates a slightly smaller polygon inside the original boundary. The space between the original and offset boundary acts as a buffer where typically no parking stalls will intrude. This offset accounts for things like curb overhang (cars often hang ~0.5 m over curbs) and provides room for circulation or sidewalks along the edge if needed. The offset polygon will be used for placing inner parking and roads, whereas the strip between original and offset boundary might be used for outer parking or pedestrian sidewalk depending on the design mode.
Stage 2: Outer Perimeter Layout (Edge Parking)
This stage executes if the chosen layout mode includes boundary parking (Perimeter mode 1, 2, or 3). The idea is to place parking stalls along the outer edges of the lot where possible, which is often an efficient use of space.
2.1 Eligible Edges Identification: The solver examines each segment of the boundary polyline to decide if parking can be placed along it. Some edges may be excluded based on settings:
If Edges Cull is specified (e.g., user says “ignore the last N edges”), those edges are skipped (perhaps to leave an open side for other uses).
If a Side-Out index is given, it means the user specifically wants to start from a certain edge; this might determine which edge gets the first row of parking aligned.
By default (side-out = 0), all edges are considered for outer spots.
Also, edges too short to fit even one stall length are ignored entirely.
2.2 Edge-by-Edge Parking Placement: For each eligible edge, the solver attempts to line up parking spots along the inside of that edge:
It knows the stall length (depth) and angle. For 90° parking, stalls will extend inward perpendicular to the edge. For angled parking (say 45°), stalls will extend inward at that angle relative to the edge.
Stalls can be “nose-in” or “nose-out” relative to the boundary. Typically, one would park nose-in towards the boundary for perimeter parking (the front of the car faces a fence or curb). The solver assumes the drive aisle is interior to the lot, so cars along the boundary are nose-in to the boundary and will back out towards the interior drive. If the design were reversed (drive at the boundary and cars nose-in towards interior), you’d adjust accordingly. By default in an open lot, outer stalls face outward (so people unload toward the lot perimeter).
The solver positions the first stall at one end of the edge (with some small setback from the corner to avoid sticking out beyond the boundary corner). There is usually a minimum corner clearance, e.g. not placing a spot right at the very edge of a corner – leaving maybe ~50–100 cm so the car doesn’t protrude around the corner. This might be implicitly handled by the skirt offset or set as a rule of thumb.
Then it populates stalls sequentially along the edge: spacing them by the stall width (plus a tiny gap for striping if needed). For a straight edge of length L, it fits as many stalls as floor(L / stall_width). If an odd leftover length remains that’s too short for a full stall, that space either becomes an island or is just unused gap at the end.
2.3 Segmentation for Entrances: If an edge has an AccessPoint (entrance/exit) on it, the solver treats the entrance area as a break in parking. Typically, no stalls should occupy the span of the driveway. For instance, if a 500 cm wide entrance is in the middle of an edge, the solver will leave that segment clear. It effectively splits the edge into two segments (one on each side of the access) and fills each with stalls independently. Additionally, some buffer distance on each side of the driveway might be left clear for sight lines (the solver might not account for sight triangles explicitly, but a small offset of, say, 100 cm from the driveway edge could be applied to avoid a stall immediately adjacent to the gate).
2.4 Outer Stall Orientation & Aisle Provision: The solver ensures that behind the outer stalls, there is either an aisle or at least enough space for a car to back out:
In many designs, a perimeter road runs along the interior side of outer parking. In solver mode 2 (“boundary spots on both sides & inner”), it implies a drive aisle is directly behind the boundary spots, and also has another row of spots on its inner side. In mode 1 (“boundary spots & inner”), it’s a bit ambiguous but generally means there are boundary spots with an aisle behind them, but perhaps the aisle also serves inner parking further in.
The solver will allocate space for this aisle in the geometry. Practically, this means that the offset polygon (from Stage 1.5) might represent the edge of that drive aisle. Example: if stall length = 500 and the skirt = 50, the offset boundary is ~50 cm inside. The outer stall will occupy roughly 500 cm from the offset line to the actual boundary (including some overhang into skirt). Immediately inside the offset line, an aisle of specified width will be reserved.
If mode 2 or 3 is selected, the solver likely sets up a continuous perimeter drive around the lot. Mode 2 suggests boundary spots on both sides of a perimeter road: one side of the road has the outer boundary spots (nose-in to boundary), the other side of the same road has another row of spots nose-in toward the interior (essentially forming a double-loaded aisle at the perimeter). Mode 3 is similar but might limit connectivity of inner aisles.
If mode 1, possibly it allows perimeter parking but maybe not a full loop road; the implementation details are subtle, but likely at least a partial aisle exists to access those spots.
In any case, at this stage the solver earmarks the positions for outer stalls and notes that a drive lane is needed just interior to them. It might not draw the lane yet (that comes in road generation stage), but it influences how much inner area remains.
2.5 Output of Outer Spots: The result of this stage is a set of outer Spot instances fixed along the boundary edges (with their geometry defined – position, orientation, etc.). These are marked perhaps as "outer" in an intermediate sense (though in data they may just be regular spots with a flag, or possibly they are handled by using an “Outer Spot” component settings separately). The solver tracks which edges have been populated and how far the last stall is from the end of each edge (to inform island creation or alignment with inner layout later).
Any gaps at corners or near entrances that are not filled by stalls effectively become potential corner islands. The solver will later turn those gaps into Island objects (or merge them with pedestrian walkways if applicable).
Example: Consider a rectangular lot and perimeter mode = 1. The solver will place a row of perpendicular stalls along each of the four sides (except where entrances are). Each side’s inner boundary becomes the edge of a 600 cm drive aisle. Now the interior shape left (within the loop of aisles) is smaller – basically the offset polygon minus space for aisles on each side.
Stage 3: Axial Road Division (Internal Subdivision)
In this stage, the solver addresses how to divide the interior area for efficient parking layout. An axial road is an internal drive aisle that cuts across the lot, typically to break a large field of parking into more manageable sections and to provide additional access/circulation.
3.1 Determine Need for Axial Road: There are two ways an axial road can be introduced:
The user can explicitly supply one or more line curves via the Axial Road input. If provided, the solver will use those as fixed positions for internal roads.
If none given, the solver decides if an axial road is beneficial. Criteria might include: the lot’s dimensions (if the lot is very deep such that a single aisle with back-to-back stalls would exceed comfortable walk distances or cause a dead-end, an axial cross aisle may be added), or for traffic flow (connecting multiple access points).
Common practice: In a long rectangular lot, a central axial road running longitudinally can split the area so cars can circulate without going around the entire perimeter. Also, large lots often have a cross aisle approximately every 5–7 double rows for pedestrian safety and to reduce dead-end lengths.
3.2 Axial Road Placement: If the solver decides to add one:
For a roughly rectangular or evenly shaped lot, it might place a single axial road through the midpoint of the longer dimension. For example, splitting the parking area into two halves. This road is oriented perpendicular to the main parking aisles (so if main aisles run east-west, an axial road might run north-south through the center).
If multiple access points on different sides were input, an axial road might connect them. E.g., if entrances are on opposite ends of the lot, an axial road linking them straight through makes sense.
The axial road’s width is taken from the Axial Width parameter (maybe slightly narrower than main entrance road if desired, default might be ~500 cm).
The road line may span from one side of the boundary to the other, or from one perimeter road to the opposite perimeter road.
The solver ensures that this road line doesn’t cut too close to an existing stall. If the axial road would intersect some of the outer or soon-to-be inner stalls, adjustments are needed (like maybe that stall is omitted to make space for the road). In practice, it likely planned the axial road position before finalizing inner stall layout, so it reserves that corridor.
3.3 Subdivide the Plot: The presence of an axial road effectively divides the interior region into two (or more) subregions. For each subregion, the solver will handle parking layout separately in the next stage. For example, if a single axial road cuts the lot into a north section and south section, each section will have its own set of parking rows oriented potentially the same way but split by the road gap.
The solver might trim the offset boundary (from Stage 1.5) with the axial road line, effectively creating separate polygons for each side.
It also likely adds a bit of intersection flaring where the axial road meets the perimeter aisles, to ensure continuity of drive paths (but that detail is more about road output stage).
3.4 Single-Access Inner Roads (Mode 3 specifics): If the perimeter mode 3 (inner roads having single access) is set, it implies that internal aisles (the ones we’re about to generate in Stage 4) will not be connected on both ends. In other words, they’ll dead-end on one side, presumably into the axial road or perimeter. This is a particular design choice to possibly maximize stalls (at the cost of requiring drivers to turn around). If this mode is on, the solver at this point plans for some aisles to terminate. For example, it might decide that interior parking rows will only be accessible from one end (maybe from the axial road side) and closed on the other end with an island or curb. We mention this now because it affects how we generate the rows in the next stage (one end of the row will not connect through).
3.5 Reserve Space for Pedestrians (if needed): If the chosen pedestrian circulation style is to put a pedestrian lane through the center of the lot rather than around the perimeter (Pedestrian Style 0 vs 1), the solver might use the axial road as a dual-purpose corridor – vehicles and pedestrians – or allocate a separate pedestrian path along or parallel to the axial road. This consideration might adjust the axial road placement slightly (e.g., widening it to include a walkway, or offsetting stalls to leave a sidewalk zone). For now, the solver’s main focus is the vehicular aspect; dedicated ped paths are addressed in Stage 8.
After this stage, the lot is conceptually divided into manageable zones: possibly an “upper” and “lower” section separated by the axial road (or left whole if no axial road is used). Now the solver tackles filling those zones with parking rows.
Stage 4: Inner Parking Row Layout
With outer edges and any axial division set, the solver now focuses on the interior area(s) – the space where one or multiple back-to-back parking rows with aisles will be placed. This is the core of the parking lot filling.
4.1 Compute Available Width: For each interior subregion (if no axial road, it's just the offset boundary minus perimeter aisles), the solver determines the effective width available in the direction perpendicular to the parking rows. For example, suppose we have a central area between the north and south perimeter roads; if the lot total width (north-south) was 50 m and each perimeter stall + aisle takes ~11 m (5 m stall + 6 m aisle) on each side, then the interior left is 50 - 2*11 = 28 m. This 28 m is available for placing additional parking rows and aisles.
If an axial road also runs through, subtract its width too. Following the example, if an axial road of 5 m runs east-west dividing, then each half (north interior vs south interior) might have 28/2 = 14 m minus a bit for clearance near the axial road.
4.2 Determine Number of Parking Modules: The solver treats a parking module as typically a pair of back-to-back stalls with an aisle between (for two-way aisles). In perpendicular parking design:
One module = Stall depth + Aisle width + Stall depth.
For example, 500 (stall) + 600 (aisle) + 500 (stall) = 1600 cm is one full double-loaded aisle module.
If the interior available width is 2800 cm, it can fit 1 module (1600) and have 1200 leftover – which could accommodate another module? Actually 2800 could fit one full double-loaded (1600) plus maybe a single-loaded half module (500 + some buffer).
The solver will pack as many full modules as possible. Each full module yields two rows of spots.
If there’s remainder space that’s more than a stall depth, it might accommodate a single-loaded row (just one stall row with either a one-sided aisle or just a backing onto an island).
For example, if interior space = 1400 cm, that can fit 1 stall + aisle (500+600=1100) plus 300 leftover which is not enough for another stall; so it would likely do one double-loaded aisle and leave 300 as buffer (or adjust slightly by maybe using a narrower aisle if allowed or pushing stalls into buffer evenly).
For angled parking, the module spacing changes: stall depth is effectively longer (measured perpendicular to aisle) if angled, but aisle could be one-way and narrower. The solver uses the “Road Width” parameter associated with the spot angle to compute the module size. For example, for 45° parking, the required back-out lane might only be ~350 cm one-way, and stall depth say ~500 still (the car is angled but the depth from curb is slightly less, maybe ~) – the plugin likely has preset effective depths for angled scenarios. It would use those to fill the space similarly.
4.3 Layout Parallel Rows: Once it knows how many rows (and aisles) can fit, the solver proceeds to actually lay them out:
Starting from the perimeter road or axial road on one side, it offsets a line inward by the stall depth to mark the first inner parking row’s alignment.
Then offset by aisle width to mark the aisle center, then offset another stall depth for the next row, and so on.
Essentially, it draws a series of guideline lines across the interior: e.g., a set of parallel lines each representing either a row of spots or the centerline of an aisle. The pattern (for perpendicular, double-loaded aisles) would be: Row line, then (stall depth away) Aisle center line, then (stall depth away) next Row line, etc.
If the last segment of space is a single row without another row behind it (like a single-loaded condition), the solver will still allocate an aisle or walkway behind it if needed or at least the skirt buffer.
4.4 Alignment and Patterning: The solver may need to align these rows with the edges of the subregion:
If a Reference Edge was set (say the south edge), likely the first row originates from that side. If symmetrical, maybe it centers the pattern.
If Snap Access is enabled, the solver might adjust the positions of these rows slightly to optimize the distribution relative to the entrance. For example, it might shift the entire grid a bit so that an aisle aligns exactly with the entrance road, improving connectivity (so cars entering go straight down an aisle). This snap could mean the first aisle from an entrance is at a comfortable distance. The solver would move the row lines incrementally (say by half a stall width or similar) to get a better fit if the initial division left an awkward small remainder at one end.
If an axial road is present dividing the space, the solver will ensure a drive aisle aligns with it if possible. Typically, you want the axial road to intersect aisles perpendicularly, not cut through a row of cars. So the row pattern might be set such that the axial road falls exactly where an aisle would be. If it doesn’t naturally, the solver might shift the pattern or treat the axial road itself as one aisle in the count.
4.5 Boundary Trimming: At the edges of the subregion (which correspond to near the main boundary or near the axial road or perimeter road), the solver ensures there is either a half-module or an island:
For instance, after laying out full modules, if there’s leftover space adjacent to the axial road of, say, 300 cm, that space might just become a pedestrian walkway or island rather than trying to squeeze a partial row.
Similarly, next to the perimeter road, any gap between the last full row and the perimeter can serve as a buffer (if small) or a sidewalk.
These decisions follow design norms: it’s better to leave some space than to cram an undersized stall. The plugin likely has thresholds for when to add a single-loaded row vs leave as open space. For example, if leftover > stall depth * 0.8 maybe a single row is attempted; if smaller, leave as buffer.
4.6 Resulting Row Guides: By the end of this stage, we have the interior layout framework:
Lines indicating where each parking row will be.
Lines indicating where each aisle will run.
Possibly identification of which aisles are through aisles connecting to others, and which may dead-end if mode 3 (the solver knows mode 3 means probably the innermost aisles will be dead-ends).
These guides are still abstract; actual stall and road geometry come next. But conceptually, we now know, for example, “there will be 3 double-loaded aisles running east-west, creating 4 rows of parking in the north section and 4 in the south section”, etc.
Stage 5: Parking Stall Generation (Inner Area)
Now the solver generates actual Spot geometry for the inner parking rows defined in Stage 4.
5.1 Stall Spacing Along Rows: For each row line determined:
The solver takes the row line (which is parallel to the reference edge/orientation) and essentially treats it as the back-of-stall line (the line along which the rear-ends of cars will align, or the front if cars face the opposite way).
Then it populates parking spots along that line, similar to how it did for the perimeter edge in Stage 2. It divides the row line into segments of length equal to stall width (plus a small striping gap). Essentially, it projects points along the row line every stall_width cm.
Each point becomes the center (or rear) of a parking spot. The spot rectangle is then generated at that point, oriented at the specified angle relative to the row line:
If 90° parking, the spot’s length axis is perpendicular to the row line (the row line could represent a curb or boundary behind the spot).
If angled, the orientation is rotated accordingly. The solver probably handles this by having a known offset direction for the spot polygon relative to the row line.
In a double-loaded aisle scenario, two rows share an aisle: one row on each side of the aisle. Often, the row lines for back-to-back stalls might coincide (if no physical barrier between backs of cars). But the solver might treat them as separate row lines offset from the aisle center in opposite directions.
If “Stack” is allowed for 45° spots, it implies one can have back-to-back angled spots (i.e., cars pointed head-to-head at 45° on either side of a center line). The solver would then pair spots from two opposite rows such that their tails align along a common line, optimizing space. This is a complex geometric situation but effectively means offsetting alternate spots. If enabled, it ensures 45° rows interlock properly.
5.2 Collision and Boundary Check: As each spot is generated, the solver checks that it lies entirely within the lot boundary (specifically within the offset boundary if we are avoiding protrusions). Any part of a spot polygon that falls outside should trigger that spot’s removal:
The plugin likely uses a boolean intersection: if the spot rectangle does not fully intersect the interior region polygon, it is discarded. For example, near edges that are not perfectly straight, end spots might stick out – those are culled.
If a spot overlaps with an earlier placed axial road or a reserved pedestrian area, it’s also removed.
The solver may leave a little gap at the ends of each row by not placing a spot if it would conflict with the boundary or a corner island. This results in nicely trimmed rows of parking.
5.3 Generating Spot Data: For each valid spot, the solver records its parameters (like position, orientation, etc.) and classifies it as an inner spot. These use the “Inner Spot” settings (length, width, angle as specified by the Inner Spot component). Outer spots used the Outer Spot settings, so potentially the inner ones could differ (though typically a user would keep them same size, but the plugin allows e.g. different angle on inner vs outer). The solver applies the correct dimensions as per those settings.
5.4 Aisle Relationship: As spots are placed on both sides of an aisle, the solver inherently establishes which aisle serves which spots. It could assign the adjacentRoadId for those spot objects now, linking them to the aisle’s road id (to be created in Stage 6). This is behind-the-scenes, but it’s where the data model integration happens: the solver knows spot group X and Y belong to aisle A, etc.
5.5 Islands at Row Ends: If an aisle (road) does not extend indefinitely, the ends of rows become turning areas or islands. The solver will notice if a row of spots terminates before the boundary:
For example, at the very interior end of a dead-end aisle (mode 3), after the last spot, there needs to be some space for a car to maneuver. The solver might automatically leave that space as a clear area or designate it as an island (perhaps with a curved radius equal to Island Radius setting to allow turning). It might create a triangular or rectangular island at the end of the aisle, preventing a stall from being placed there and providing a physical buffer.
Similarly, where an axial road crosses, the spots near that intersection likely stop a bit short to create a clearance. That clearance can be output as an island or just open space. The solver could formalize it as an island polygon (with corners filleted by Island Radius for smooth flow).
These island placements are important for geometry stability (no collisions) and mimic real design where you often see landscaped islands at the ends of parking rows for safety.
5.6 Summary of Spots: By the end of this stage, essentially all parking stalls (spots) are laid out – both outer edge stalls (from Stage 2) and inner stalls (from this stage). They are placed in their final positions. None of them are yet marked as special (handicap/elderly) – they’re all just generic at this point (that comes in Stage 9). They maximize coverage of the lot while respecting geometry constraints:
They fill along edges where allowed,
They fill interior in a grid, trimmed at boundaries and roads,
They avoid overlaps and leave necessary gaps for roads and turning.
In short, the solver has drawn every possible parking rectangle that fits given the chosen configuration, yielding the maximum count for that configuration (subject to any user exclusions or percentages reserved for other uses).
Stage 6: Drive Aisle and Road Generation
With all parking spots positioned, the solver now finalizes the road geometry that weaves through the parking layout.
6.1 Perimeter Road Construction: If outer parking was placed (modes 1–3), the solver constructs the perimeter circulation road that runs behind those outer stalls:
Essentially, it takes the offset boundary from Stage 1.5 as a base, possibly offset it further inward by half the aisle width to get the centerline of the perimeter road.
This road likely traces the shape of the boundary, but may have breaks at access points and corners.
At corners of the lot, where two perpendicular perimeter aisles meet, the solver will create a fillet or an intersection curve so vehicles can turn. The Island Radius parameter might be used here to round the corner of the drive aisle or to define the corner island radius.
If mode 2 (double-loaded perimeter), this perimeter road has stalls on both its outside (already placed) and its inside (the first row of inner stalls). So it’s a standard aisle servicing two sides. If mode 1, perimeter road has stalls on one side (outer) and maybe open space or sidewalk on the outside; on its inside, either it borders another subregion of parking or just the open interior.
The solver defines each perimeter road segment as a polyline (or perhaps a series of line segments and arcs at corners).
6.2 Axial Road Formation: If an axial road was planned in Stage 3, now the solver generates it as an actual road geometry:
It will create a corridor of the specified axial width through the lot. If the axial road runs from one perimeter road to the opposite side, it intersects those roads. The solver will ensure a proper intersection: likely it stops the perimeter stalls short so the axial road can pass, and it may introduce a small corner island or fillet at the junction to guide cars.
In practice, at the intersection of an axial road and a perimeter road (or any other road), design might include an island or at least paint to separate conflict points. The solver might not fully detail intersection markings, but it will carve out space. For example, it might leave a square open area at the cross, which effectively is an intersection area (which could be considered part of the road network).
The axial road’s alignment was set to match an aisle spacing, so likely it flows as a continuous aisle as well.
If multiple axial roads or a more grid-like network is present (not common in a single-lot scenario, but possible if user added them), the solver draws each and handles their intersections similarly.
6.3 Internal Aisles: For each interior parking aisle (between back-to-back rows of spots), the solver now has the spot layout which implicitly defines where the aisle runs (the gap between the two rows). It generates these aisles as road surfaces:
Typically, for a double-loaded row, the aisle centerline runs equidistant from the two facing rows of stalls.
The solver will create a polyline for each such aisle, likely spanning from one cross-aisle to another or from a cross-aisle to a dead-end.
If mode 3 (dead-end aisles), an aisle might terminate inside the lot. At the termination, previously an island might have been placed. The solver ensures the road geometry stops at that island. There might be a bulb-out or hammerhead shape if turning space is needed – but often a dead-end aisle in parking just ends with an island for a car to pivot around. The solver may simply stop drawing the road at that point and rely on the island to mark the end.
If not mode 3, aisles likely connect either to perimeter roads or axial roads on both ends, forming a continuous path (no dead end).
For each aisle, the solver sets the aisle width (centerline offset half-width each side to curb or stall edge). The road surface can be represented as a region between stall edges and any adjacent islands.
6.4 Connectivity Check: After generating all roads, the solver ensures that all parking spots are reachable from an access point via the road network:
This is implicitly true if the design is done correctly: perimeter roads connect to entrance(s), axial and interior aisles connect to perimeter or each other.
The solver might do a quick graph traversal internally: marking each road and connection to verify continuity. If it finds an isolated aisle that doesn’t connect (which would be a mistake), it could adjust (though such a scenario is unlikely given how we laid things out systematically).
If multiple AccessPoints exist, the network may have multiple exit routes. That’s fine as long as everything is connected somewhere.
6.5 Marking Pedestrian Lanes on Roads: If Pedestrian Style = 0 (lanes at roadside), this means pedestrian circulation is accomplished by using part of the road or aisle edges as walking paths. For example, the solver might designate a 100 cm strip along certain aisles as a walkway (often done by painting a stripe in real lots). In terms of output, the solver could mark those lanes either by offset lines or by splitting the road surface. If it does so, at this stage it might create offset curves 50 cm from the road edges to delineate a sidewalk. However, since the actual creation of distinct pedestrian geometry is in Stage 8, here it might just note the needed space. Still, we mention it because the road geometry needs to account for it: if an aisle hosts a pedestrian lane, the effective driveable width might be reduced or the total width increased to accommodate both. The solver likely simply ensures the Circ. Width (ped circulation width) is either part of the road or an adjunct path – in style 0, it’s basically part of the road cross-section.
6.6 Output of Roads: The solver now outputs each road as a distinct element (for example, the Grasshopper component will have a Roads output listing all road segments with their curves). Each road segment gets its attributes (width, type, etc.) assigned per the Road Settings. At this time, any islands that needed to be created (like at intersections or row ends) are also finalized as separate geometry (and will be handled in Stage 7).
6.7 Corner and Intersection Islands: Where roads intersect or turn, the solver might create small triangular or curved islands:
For instance, at the 90° bends of a perimeter road, rather than having a sharp corner, often a triangular island is placed to guide the turn and provide a bit of refuge (and possibly host signage or landscaping). The Island Radius can dictate rounding these corners. The solver likely fillets the inside corner of the drive path by that radius, effectively cutting out a triangular piece – that piece becomes an island.
At a T-intersection of an axial and a perimeter road, there might be a small island opposite the T to split incoming traffic directions. The solver could leave an island in such places if geometry allows, though it might also just leave pavement; this is somewhat design-specific and the current solver might not add a median island unless specifically triggered.
Nonetheless, any area not needed for vehicle paths at intersections will be labeled as an Island region (to ensure no spots occupy it and to output it as such for clarity). This stage identifies those and ensures they’re removed from driveable road surfaces.
At the end of Stage 6, the road network is fully defined: all driving aisles (perimeter, axial, internal) are delineated, and all non-driving spaces leftover are implicitly islands (though pedestrian paths are addressed next). The parking lot is now essentially laid out in terms of where cars can drive and park.
Stage 7: Pedestrian Circulation Integration
With cars and roads in place, the solver addresses pedestrian circulation – the pathways for people on foot within the parking lot. Safe pedestrian movement is a key aspect of European best practices, ensuring that those who park can reach destinations (building entrances, sidewalks) without walking in active drive aisles more than necessary.
The plugin supports two styles of pedestrian lane integration:
Style 0: Lanes at Roadside. In this mode, pedestrian paths run adjacent to driving aisles, essentially sharing the space of the aisles (demarcated by paint). Think of this as a shoulder or side stripe along the road where pedestrians can walk.
Style 1: Sidewalks (separated lanes). In this mode, dedicated sidewalk surfaces are created, which might be at the perimeter or between parking bays, segregated from vehicle lanes.
We handle each accordingly:
7.1 Style 0 – Roadside Pedestrian Lanes:
If selected, the solver designates a portion of certain roads as pedestrian lane:
Typically, the Circ. Width (circulation width) parameter might be 120 cm, meaning a 1.2 m walkway at the road edge. The solver would not remove that from the road width but rather assume the road is wide enough to include it (or the road was made wider to accommodate it).
In practice, the solver could output a polyline or region representing the pedestrian lane along each road segment. For example, alongside each perimeter road and axial road, an offset line 60 cm inside from the outer edge of the road delineates the walkway boundary.
It might only mark one side of each aisle as pedestrian (commonly, the side that leads to building or main destination). E.g., in a parking lot, typically there’s a sidewalk along the side facing the building. If the plugin doesn’t know building location, perhaps it defaults to provide pedestrian lanes on all perimeter roads on the interior side, and maybe along axial roads as well.
Because this is essentially just a marking on the road, the solver might not create a separate Island object for it; it could simply be an annotation or a property of the road (like Road has a hasPedLane: true on one side). However, to visualize it, it might output it as a narrow elongated island-like surface running parallel to the road, but really it’s flush with the road surface (just painted).
For documentation, it’s easier to think that the solver “allocates 120 cm on either one or both sides of the aisle as pedestrian lane, reducing effective drive width accordingly or requiring a wider aisle.” So if an aisle was 600 cm and ped lane 120 cm on one side, then effectively 480 cm for cars which is still fine for one-way or tight two-way. But likely, they intended the aisles to be a bit multi-use.
7.2 Style 1 – Sidewalks / Separated Paths:
If this is chosen, the solver creates sidewalk Islands explicitly:
A common approach: Surround the parking area with a sidewalk just inside the boundary. The Access Width under Pedestrian Settings might indicate how far from AccessPoints the pedestrian path extends into the lot. Possibly the Skirt offset (50 cm) plus some walkway width could form a sidewalk around the perimeter.
The solver might generate a continuous sidewalk polygon following the boundary (just inside the outer parking or along the outer drive). If outer spots exist, a sidewalk could run behind them (though behind outer spots is also the perimeter road in many cases – perhaps the sidewalk is outside the perimeter road? Without a building edge, this is tricky to guess; but maybe along the outer boundary if that boundary abuts a building or public area).
Additionally, for internal circulation, the solver could place a central walkway between certain parking rows. For example, in a lot with many rows, one good practice is to have a pedestrian aisle every few rows so people can walk parallel to the cars rather than in the drive aisle. The solver might incorporate this if the user specified (though not sure if plugin does automatically).
Another interpretation: Style 1 might put pedestrian paths at the ends of parking rows (like sidewalks crossing the lot perpendicular to aisles). Possibly connecting AccessPoints to the facility. However, given limited info, likely it creates sidewalks along the edges of the lot and maybe along the axial road if that was meant as a pedestrian spine.
Let’s assume minimal: it will create sidewalk surfaces along the outer boundary where space allows (like a 120–150 cm wide sidewalk), treating them as Islands of type "pedestrian". Perhaps it uses the Skirt offset area for this. For instance, if Skirt=50 cm and CircWidth=150 cm, it might offset the boundary inward 50 cm + 150 cm = 200 cm to get a line where outer parking starts, leaving a 150 cm sidewalk strip inside the edge. In stage 2, if that was accounted for, maybe outer stalls were placed 200 cm from actual boundary instead of 50.
If not automatically done, at least the solver can carve out space at AccessPoints for pedestrian entry – e.g., from an AccessPoint coordinate, draw a pedestrian path into the lot (maybe aligning with an axial road or a central aisle if those lead presumably to a building). That could be part of a future version though.
7.3 Pedestrian Crossing and Islands:
The solver will create any needed pedestrian crossings as part of the walkway network. For instance, if a sidewalk runs along the lot perimeter and the building is opposite the parking, you’d need crosswalks from each parking aisle end to that sidewalk. The plugin might not draw zebra crossings explicitly, but it could ensure that where pedestrian paths intersect drive aisles, an island or at least a continuous path is present.
Possibly the plugin’s approach: if Style 1, treat pedestrian paths as islands that can snake through the lot. E.g., one can imagine an island that goes between two rows, connecting to an axial road walkway, etc. The Pedestrian Access input points might indicate where pedestrians come in (like from AccessPoints or other edges), and the solver could then ensure a path from those points to, say, the far end of the lot (maybe where a building would be). Without a building given, it’s speculative; the user might manually specify ped access where they need it.
So concretely, the solver might do: for each Pedestrian Access point, generate a straight sidewalk of width = CircWidth leading into the lot for some distance or across it. Or connect that point to the nearest aisle via a perpendicular path.
7.4 Finalizing Pedestrian Geometry: Based on style:
In style 0, mark roads accordingly (which may not produce separate geometry, just metadata or lines).
In style 1, output sidewalks as actual Island objects with pedestrian type. E.g., a polygon running along the front of a row of stalls, with width given.
If sidewalks run parallel to a row of parking spots, the solver ensures those spots don’t encroach (the skirt offset likely covered it).
If a sidewalk crosses an aisle, ideally an island (e.g., a raised crosswalk) would be placed. The plugin might not raise anything, but could at least delineate it as a pedestrian crossing on the road.
7.5 Compliance and Safety: The solver attempts to follow norms, e.g. ensuring no parking spot is too far from a pedestrian path. European guidelines often aim that pedestrians shouldn’t have to walk more than a few rows distance without a safe walkway. If the solver’s algorithm doesn’t explicitly enforce that, it relies on the fact that axial roads or perimeter sidewalks handle most cases. The user should verify – but typically, by providing an axial road and perimeter sidewalks, everyone is within a short walk to some walkway.
After this stage, the layout should include clear pedestrian routes in addition to vehicular routes. In the output, the pedestrian paths would appear as either differently colored surfaces (if using a visualization mode) or as separate curves/polylines designated for walkways.
Stage 8: Assigning Special Parking Spots (Accessibility & More)
Once the physical layout of all generic parking spots is set, the solver adjusts certain spots to fulfill special requirements: handicapped (accessible) spots, elderly spots, and potentially other reserved categories. This stage ensures the final plan is not just quantity-optimized but also meets accessibility and user-group needs.
8.1 Identify Special Spot Count: Using the percentages or counts given by the user:
The solver calculates how many spots should be marked as Handicap (disabled accessible). For example, if 5% was specified and there are 100 spots, that’s 5 spots. It will round up or down as appropriate (ensuring at least 1 if percentage > 0). If local norms require a minimum (like at least 2 for certain sizes), the user should have set the percentage high enough, but the solver itself might enforce a minimum of 1 if any special percentage is set.
Similarly for Elderly (or senior/parent) spots. Often these are a smaller number, maybe similarly a percentage or a fixed count.
If other special categories were supported (e.g., “female parking” in some places, or “VIP”), those would be handled similarly if they were part of input, but our main focus is handicap and elderly since those are explicitly mentioned.
8.2 Selection of Spots for Conversion: The critical part is choosing which spots to convert into these special spots:
Location Priority: Typically, accessible spots should be the ones closest to the building or main pedestrian exit. Since the plugin doesn’t know the building, a logical proxy is to pick spots closest to the AccessPoint or pedestrian access. If the user provided a Pedestrian Access (like the walkway from lot to building), the solver can find the parking spots nearest to that point. Often, those in the row adjacent to the pedestrian path or near the entrance walkway are ideal.
If multiple access points exist, it could distribute accessible spots among them (for instance, 2 near one entrance, 1 near another).
Outer vs Inner: Usually, accessible spots are placed in areas with the easiest path of travel. If a perimeter sidewalk exists, spots adjacent to it are good candidates. So outer rows along the front of a store would be used. In absence of that info, the solver might simply take the first N spots in the list sorted by distance to some reference (like one of the access points).
For elderly (or “parents with strollers” often), these also ideally are relatively convenient but perhaps can be a bit further than handicap. The solver might choose them similarly after assigning handicap: e.g., the next closest spots become elderly.
Spacing consideration: The solver should avoid clumping all special spots unless it makes sense (often accessible spots are grouped, which is fine, but sometimes spreading them on both sides of an entrance could be good). However, given a small number, grouping them together near the access is typical.
We assume the solver picks an appropriate grouping of spots near the main pedestrian entry area for special designation.
8.3 Modify Spot Geometry: For each spot chosen as handicap:
The solver widens the spot or allocates an adjacent aisle. In practice, an accessible space in Europe might be the same 250 cm stall plus a 120 cm side access zone, or a wider stall like 350 cm. The plugin likely handles this by the Lane Width parameter in the Handicap setting. For example, if LaneWidth = 120 cm, the solver might effectively “merge” two adjacent stall spaces: one becomes the car space, the other the hatched aisle. Or it expands the stall polygon by that amount on one side.
Implementation could be: if the handicap spot has a normal neighbor on its right, convert that neighbor into the aisle (thus effectively taking up two stalls worth of width for one accessible spot). But that would reduce total count. More likely, the plugin adds the aisle as part of the same spot footprint (maybe overlapping what would have been a gap or part of an island). It might push the adjacent spot slightly further away to accommodate the extra gap.
Since the solver in its UI treats it as one component morphing the spot with lane width, it probably does not remove a spot, but instead just marks that this spot has an extra 120 cm clearance on one side (and thus that clearance overlaps the adjacent space which must then not be another car). Possibly it automatically ensures accessible spots appear at end of rows or next to islands so the clearance can be on the outer side. This is a design preference: ideally, place an accessible spot at the end of a row so its passenger side has an open aisle or island.
If not at an end, the solver might sacrifice one adjacent stall as the clearance zone. This would effectively reduce count by 1 for each handicap spot placed mid-row. Possibly the plugin tries to avoid mid-row placement for that reason.
For documentation, we can state that the solver will position handicap spots such that their side lane can be accommodated (often adjacent to an island or at row end). If a handicap spot ended up with cars on both sides, the solver might mark one side’s spot as the clearance (i.e. not place a car there).
The spot’s data is updated: type set to "handicap", and the extra lane width property is set (e.g., 120).
For each spot chosen as elderly (or similar convenience spot):
These typically do not need extra space, just signage or marking. The solver would simply mark them as such (type = "elderly"). It might cluster them also near the entrance but perhaps slightly further out than the handicap ones.
If, say, Electric Charging spots were to be designated (even though not explicitly asked, maybe as an example of other special tags), the solver could similarly mark type = "EV" for a certain percentage, ideally near power sources or building side, but that’s a user decision outside the current automation.
8.4 Ensuring Visibility: The solver may optionally adjust coloring or layering for these special spots in the preview (e.g., accessible spots might be highlighted blue in Rhino preview). In terms of logic, it ensures they are clearly differentiated in output data (and as noted earlier, currently they don’t persist on file save without re-toggle due to a bug, but in the solving process they are marked).
8.5 Regulation Compliance Check: At this stage, the solver might output a brief report or at least have data (like in the metadata) stating “X special spots assigned which is Y% of total”. It is the user’s responsibility to check compliance (e.g. Bulgaria requires at least 2 accessible in many cases, EU recommends ~4% – the plugin can meet that if used correctly). The solver doesn’t actively enforce a legal rule, it just follows the user’s input. But by making the assignment now, it ensures the design reflects the intended percentages.
After Stage 8, the parking stalls are no longer homogeneous: specific stalls are now labeled and configured as Handicap (with extra space) or Elderly (just reserved). These modifications slightly reduce the effective capacity (if any spots were removed for handicap aisle) and are the finishing touch to cater to user categories.
Stage 9: Bicycle Parking Allocation
If bicycle parking is requested (through the Bike Picker settings), the solver integrates it at this point. Bicycle parking can be handled by converting some car spaces or by using free areas.
9.1 Determine Bike Allocation Method: The user may specify a percentage of spots to be dedicated to bikes (for example, 5% of parking converted to bike racks), and/or use the interactive picker to select islands for bikes. The solver supports both:
Automatic (percentage-based): If Amount (%) for Bikes is set, the solver calculates how many car spots that corresponds to. E.g., 10% of 100 spots = 10 spots worth.
Manual Pick: The user can press the “Pick base islands for spots” button to choose specific island(s) to repurpose. These islands would likely be large leftover areas or end-of-row islands that can fit bikes.
9.2 Selecting Locations for Bikes: There are a few common strategies:
Repurpose End Spots: Often, one or two car spots at a convenient location (near an entrance or building) are converted to a bike parking area. The solver might choose the spots farthest from the entrance (which is opposite of handicap strategy) if trying not to impact drivers, but usually you want bike parking also near destinations. Let’s assume it aims for somewhere safe and a bit out of the way of cars – possibly corner of the lot or an island near the entrance but out of driving lanes.
Use Islands: If the layout has large islands (e.g., a central unused area or wide buffer), those are great candidates for bike racks. The solver would identify islands above a certain size and pick them to host bike parking. This is likely what the Bike Picker “Pick base islands” does – user chooses an island interactively, then the solver places bike spots there.
Possibly, the plugin can also split a single car spot into multiple bike stands. For example, one car space (~12.5 m²) could fit roughly 10 bicycles. The solver might convert the geometry of a car spot into a cluster of bike rack symbols (though actual rack modeling is beyond scope).
It may also use the parameter Lateral distance (90 cm by default) to layout bikes within a spot or island, essentially spacing bike stands 90 cm apart laterally.
9.3 Converting a Car Spot to Bike Spot: If doing so:
The solver will remove that car spot from the list (or mark it as type “bicycle”).
It then creates multiple bike stall markers within that car spot footprint. Perhaps it will simply note that this spot can hold N bikes (like an attribute rather than drawing each bike).
The Spot Length setting for bikes (180–240 cm range) suggests it might plan for different bicycle lengths (some bikes + rack might need ~180 cm). If the car spot depth is 500 cm, it could even fit two rows of bikes deep (one on each side of a central rack) if accessible from both sides. But details aside, it at least knows the typical bike footprint.
If multiple car spots in a row are converted, it might combine them into one bigger bike parking zone.
9.4 Utilizing Islands for Bikes: If using an island:
The solver will carve space on that island equivalent to some number of bike racks. Possibly it will align racks parallel to the island’s longer side.
The Border offset param (default not given explicitly, but likely for how close to island edge to place bikes) might be used to keep racks a bit inside the island edges for safety.
It then effectively changes the island’s type to “bike_pad” and records how many bikes (the Amount (%) or a fixed number) it accommodated.
9.5 Ensuring Accessibility for Bicycles: The solver should ensure there is a way for cyclists to reach these bike spots without carrying bikes over cars or curbs unnecessarily. If the bike parking is on an island in the middle of the lot, ideally that island is adjacent to a pedestrian path or near an entrance. The user likely picks an island that is convenient (like near the front or a corner). The solver might not add anything beyond that, but we consider:
If bike spot is at a perimeter, cyclists likely come from the outside, so an AccessPoint could also be used by bikes or a gap in curb exists.
If in interior, hopefully it’s next to an axial pedestrian path or so.
9.6 Finalize Bike Spots Data: The solver will output the bike parking allocation:
Possibly as special Spot objects (type “bicycle”) for each converted car stall.
Or as part of island data (like an island now has bike racks).
Or both (the plugin has a “Bike Picker” component separate from Spots, so it might list them separately).
For simplicity, we consider that in the final documentation the bike spots are indicated clearly.
At the end of Stage 9, the parking layout is complete with all intended elements:
All car spots (regular and special) placed.
Drive aisles and circulation roads in place.
Pedestrian walkways integrated.
Bicycle parking allocated.
Islands defined wherever space is unused or reserved.
Stage 10: Output Assembly and Visualization
The solver now compiles all results and prepares them for output through Grasshopper and Rhino.
10.1 Compile Data Structures: Internally, the solver creates lists for each element type:
A list of Spot objects (with their coordinates, dimensions, type tags, etc.).
A list of Road objects (with their polylines and widths).
A list of Island objects (with polygons).
A list of AccessPoints (likely just echoing inputs, maybe with some snapping adjustments).
These correspond to what was described in the Data Model section of the documentation. The solver’s outputs Spots and Roads (and possibly Islands info) are prepared to send to the Grasshopper component outputs.
10.2 Visualization Layer: If the user toggled Visualize = true, the solver generates display geometry with distinct styling:
It might create colored surfaces or outlines for different spot types (e.g., blue fill for handicap spots, yellow for elderly, green for bike, white for regular).
It may draw the lane markings for pedestrian paths (e.g., dashed lines along aisles if style 0).
It could also place text or symbols (like a wheelchair symbol) at handicap spots in the Rhino view, though that might be beyond its scope. Likely not; probably just color coding.
The visualization might also include drawing arrows or indications on the roads (like entry arrows at access points, etc., but not sure if implemented).
When Visualize is off, it might output just the raw geometry minimally (outlines of spots, etc., or even just count data).
10.3 Final Output to User: The Grasshopper component provides outputs that users can bake or use:
Curves or surfaces representing parking stall boundaries (so the user can bake them as paint lines or blocks).
Curves/surfaces for roads and islands.
Perhaps points or markers for access and special spots.
Also, possibly some summary outputs (like total count, etc.). The "Spots Info" and "Roads Info" components can deconstruct the objects to text or values. For instance, Spots Info might output a list of spot center points and maybe their type, which users can then use to label spaces or count them.
The solver might also log a brief summary to the Rhino command line or a panel (e.g., "Generated 100 spots (3 handicap, 2 elderly, 5 converted to bike), 4 aisles, 1 entrance").
10.4 Clean-up and Stability: The solver double-checks that no degenerate geometry remains:
If a spot was completely removed (like a duplicate or one that was turned into an aisle), ensure it’s not still in the list.
If any island ended up zero-area (maybe an overlap resolved that made an island disappear), drop it.
If any tiny gap slivers of islands exist that aren’t meaningful, optionally drop if below a threshold (this isn’t always done automatically, but it could be nice).
10.5 User Interaction for Edits: After output, the user might tweak things (the solver won’t automatically adjust further unless parameters change). However, some interactive features remain:
The Bike Picker Reset button allows the user to remove all bike spots if they want to try different allocation. Pressing that would essentially restore those as car spots (or free islands).
If the user moves an AccessPoint slightly or toggles a mode, the solver reruns from Stage 1 to 10 quickly to update the layout.
Throughout these stages, the solver adhered to key design rules:
Stall dimensions and counts reflect European standards (with customization possible to meet Bulgarian specifics like slightly larger stalls if needed).
Aisles are appropriately sized and connect properly.
There are provisions for pedestrian safety (via sidewalks or lanes) and accessibility (reserved larger spots) in line with regulations.
Bicycles are considered as part of modern best practices to encourage multi-modal use.
The outcome is a stable and flexible parking layout:
Stable in that small changes (like moving an entrance or toggling adding an axial road) won’t produce wildly broken geometry – the algorithm is geometry-first and handles these logically (though very concave shapes remain a known difficulty).
Flexible in that the user can override many parameters (stall size, angle, percentages, etc.) to tweak the layout, and the solver will adapt the solution accordingly without manual redesign.
Finally, the user can bake the geometry into Rhino for final drafting, or adjust parameters to iterate on the design. The solver’s stage-by-stage process ensures the final parking lot layout is both efficient and adherent to design norms, requiring only minimal user adjustments to reach a permit or construction drawing level.